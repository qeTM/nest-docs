import{_ as a,c as i,o as n,ag as p}from"./chunks/framework.CCM1LoTM.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"42. 提升 Dockerfile 水平的 5 个技巧.md","filePath":"42. 提升 Dockerfile 水平的 5 个技巧.md"}'),l={name:"42. 提升 Dockerfile 水平的 5 个技巧.md"};function e(t,s,c,h,o,d){return n(),i("div",null,s[0]||(s[0]=[p(`<p>Docker 是一种容器技术，它可以在操作系统上创建多个相互隔离的容器。容器内独立安装软件、运行服务。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-1.png" alt="" loading="lazy"></p><p>但是，这个容器和宿主机还是有关联的，比如可以把宿主机的端口映射到容器内的端口、宿主机某个目录挂载到容器内的目录。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-2.png" alt="" loading="lazy"></p><p>比如映射了 3000 端口，那容器内 3000 端口的服务，就可以在宿主机的 3000 端口访问了。</p><p>比如挂载了 /aaa 到容器的 /bbb/ccc，那容器内读写 /bbb/ccc 目录的时候，改的就是宿主机的 /aaa 目录，反过来，改宿主机 /aaa 目录，容器内的 /bbb/ccc 也会改，这俩同一个。</p><p>这分别叫做端口映射、数据卷（volume）挂载。</p><p>这个容器是通过镜像起来的，通过 docker run image-name。</p><p>比如:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker run -p 3000:3000 -v /aaa:/bbb/ccc --name xxx-container xxx-image</span></span></code></pre></div><p>通过 xxx-image 镜像跑起来一个叫做 xxx-container 的容器。</p><p>-p 指定端口映射，映射宿主机的 3000 到容器的 3000 端口。</p><p>-v 指定数据卷挂载，挂载宿主机的 /aaa 到容器的 /bbb/ccc 目录。</p><p>这个镜像是通过 Dockerfile 经过 build 产生的。</p><p>也就是这样的流程：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-3.png" alt="" loading="lazy"></p><p>一般在项目里维护 Dockerfile ，然后执行 docker build 构建出镜像、push 到镜像仓库，部署的时候 pull 下来用 docker run 跑起来。</p><p>基本 CI/CD 也是这样的流程：</p><p>CI 的时候 git clone 项目，根据 dockerfile 构建出镜像，打上 tag，push 到仓库。</p><p>CD 的时候把打 tag 的镜像下下来，docker run 跑起来。</p><p>这个 Dockerfile 是在项目里维护的，虽然 CI/CD 流程不用自己搞，但是 Dockefile 还是要开发者自己写的。</p><p>比如我创建一个 nest 项目：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npx nest new dockerfile-test -p npm</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-4.png" alt="" loading="lazy"></p><p>然后执行 npm run build，之后把它跑起来：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm run build</span></span>
<span class="line"><span>node ./dist/main.js</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-5.png" alt="" loading="lazy"></p><p>这时候访问 <a href="http://localhost:3000" target="_blank" rel="noreferrer">http://localhost:3000</a> 可以看到 hello world，说明服务跑成功了:</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-6.png" alt="" loading="lazy"></p><p>那如何通过 Docker 部署这个服务呢？</p><p>我们来写下 Dockerfile：</p><div class="language-docker vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">docker</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node:18</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WORKDIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /app</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> package.json .</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> *.lock .</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> npm config set registry https://registry.npmmirror.com/</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> npm install</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> . .</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> npm run build</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">EXPOSE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 3000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CMD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./dist/main.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]</span></span></code></pre></div><p>FROM node:18 是继承 node:18 基础镜像。</p><p>WORKDIR /app 是指定当前目录为 /app</p><p>COPY 复制宿主机的 package.json 和 lock 文件到容器的当前目录，也就是 /app 下</p><p>RUN 是执行命令，这里执行了 npm install。</p><p>然后再复制其余的文件到容器内。</p><p>EXPOSE 指定容器需要暴露的端口是 3000。</p><p>CMD 指定容器跑起来时执行的命令是 node ./dist/main.js。</p><p>然后通过 docker build 把它构建成镜像：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker build -t dockerfile-test:first .</span></span></code></pre></div><p>-t 是指定名字和标签，这里镜像名为 dockerfile-test 标签为 first。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-7.png" alt="" loading="lazy"></p><p>然后在 docker desktop 的 images 里就可以看到这个镜像了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-8.png" alt="" loading="lazy"></p><p>就是现在镜像稍微大了点，有 1.45 G。</p><p>我们先跑起来看看：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker run -d -p 2333:3000 --name first-container dockerfile-test:first</span></span></code></pre></div><p>-d 是后台运行。</p><p>-p 指定端口映射，映射宿主机的 2333 端口到容器的 3000 端口。</p><p>--name 指定容器名</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-9.png" alt="" loading="lazy"></p><p>然后就可以看到容器部分有了这个容器了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-10.png" alt="" loading="lazy"></p><p>浏览器访问 <a href="http://localhost:2333" target="_blank" rel="noreferrer">http://localhost:2333</a> 就可以访问容器内跑的这个服务：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-11.png" alt="" loading="lazy"></p><p>这就是 Dockerfile 构建成镜像，然后通过容器跑起来的流程。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-12.png" alt="" loading="lazy"></p><p>但是刚才也发现了，现在镜像太大了，有 1.45G 呢，怎么优化一下呢？</p><p>这就涉及到了第一个技巧：</p><h2 id="使用-alpine-镜像-而不是默认的-linux-镜像" tabindex="-1">使用 alpine 镜像，而不是默认的 linux 镜像 <a class="header-anchor" href="#使用-alpine-镜像-而不是默认的-linux-镜像" aria-label="Permalink to &quot;使用 alpine 镜像，而不是默认的 linux 镜像&quot;">​</a></h2><p>docker 容器内跑的是 linux 系统，各种镜像的 dockerfile 都会继承 linux 镜像作为基础镜像。</p><p>比如我们刚刚创建的那个镜像，点开详情可以看到它的镜像继承关系：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-13.png" alt="" loading="lazy"></p><p>最终还是继承了 debian 的 Linux 镜像，这是一个 linux 发行版。</p><p>但其实这个 linux 镜像可以换成更小的版本，也就是 alpine。</p><p>它裁剪了很多不必要的 linux 功能，使得镜像体积大幅减小了。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-14.png" alt="" loading="lazy"></p><p>alpine 是高山植物，就是很少的资源就能存活的意思。</p><p>我们改下 dockerfile，使用 alpine 的镜像：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-15.png" alt="" loading="lazy"></p><p>node:18-alpine3.14 是使用 18 版本的 node 镜像，它底层使用 alpine 3.14 的基础镜像。</p><p>然后 docker build</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker build -t dockerfile-test:second .</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-16.png" alt="" loading="lazy"></p><p>这次的 tag 为 second。</p><p>然后在 docker desktop 里看下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-17.png" alt="" loading="lazy"></p><p>好家伙，足足小了 900M。</p><p>我们点开看看：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-18.png" alt="" loading="lazy"></p><p>可以看到它的底层 linux 镜像是 alpine3.14。</p><p>体积小了这么多，功能还正常么？</p><p>我们跑跑看：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker run -d -p 2334:3000 --name second-container dockerfile-test:second</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-19.png" alt="" loading="lazy"></p><p>docker desktop 可以看到这个跑起来的容器：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-20.png" alt="" loading="lazy"></p><p>浏览器访问下，依然是正常的：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-21.png" alt="" loading="lazy"></p><p>alpine 只是去掉了很多 linux 里用不到的功能，使得镜像体积更小。</p><p>这就是第一个技巧。</p><p>然后再来看第二个：</p><h2 id="使用多阶段构建" tabindex="-1">使用多阶段构建 <a class="header-anchor" href="#使用多阶段构建" aria-label="Permalink to &quot;使用多阶段构建&quot;">​</a></h2><p>看下这个 dockerfile，大家发现有啥问题没：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-22.png" alt="" loading="lazy"></p><p>有的同学可能会说：为什么先复制 package.json 进去，安装依赖之后再复制其他文件，直接全部复制进去不就行了？</p><p>不是的，这两种写法的效果不同。</p><p>docker 是分层存储的，dockerfile 里的每一行指令是一层，会做缓存。</p><p>每次 docker build 的时候，只会从变化的层开始重新构建，没变的层会直接复用。</p><p>也就说现在这种写法，如果 package.json 没变，那么就不会执行 npm install，直接复用之前的。</p><p>那如果一开始就把所有文件复制进去呢？</p><p>那不管 package.json 变没变，任何一个文件变了，都会重新 npm install，这样没法充分利用缓存，性能不好。</p><p>我们试试看就知道了：</p><p>现在重新跑 docker build，不管跑多少次，速度都很快，因为文件没变，直接用了镜像缓存：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker build -t dockerfile-test:second .</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-23.png" alt="" loading="lazy"></p><p>现在我们改下 README.md：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-24.png" alt="" loading="lazy"></p><p>然后重新跑 build：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-25.png" alt="" loading="lazy"></p><p>现在花了 25s，其实是没有重新 npm install 的。</p><p>然后改下 package.json：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-26.png" alt="" loading="lazy"></p><p>再跑 docker build</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-27.png" alt="" loading="lazy"></p><p>时间明显多了很多，过程中你可以看到在 npm install 那层停留了很长时间。</p><p>这就是为什么要这样写：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-28.png" alt="" loading="lazy"></p><p>这里没问题，大家还能发现有没有什么别的问题么？</p><p>问题就是源码和很多构建的依赖是不需要的，但是现在都保存在了镜像里。</p><p>实际上我们只需要构建出来的 ./dist 目录下的文件还有运行时的依赖。</p><p>那怎么办呢？</p><p>这时可以用多阶段构建：</p><div class="language-docker vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">docker</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node:18-alpine3.14 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> build-stage</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WORKDIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /app</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> package.json .</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> npm config set registry https://registry.npmmirror.com/</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> npm install</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> . .</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> npm run build</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># production stage</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node:18-alpine3.14 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> production-stage</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> --from=build-stage /app/dist /app</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> --from=build-stage /app/package.json /app/package.json</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WORKDIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /app</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> npm config set registry https://registry.npmmirror.com/</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> npm install --production</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">EXPOSE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 3000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CMD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/app/main.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>FROM 后面添加一个 as 来指定当前构建阶段的名字。</p><p>通过 COPY --from=xxx 可以从上个阶段复制文件过来。</p><p>然后 npm install 的时候添加 --production，这样只会安装 dependencies 的依赖。</p><p>docker build 之后，只会留下最后一个阶段的镜像。</p><p>也就是说，最终构建出来的镜像里是没有源码的，有的只是 dist 的文件和运行时依赖。</p><p>这样镜像就会小很多。</p><p>我们来试试看：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker build -t dockerfile-test:third -f 222.Dockerfile .</span></span></code></pre></div><p>标签为 third。</p><p>-f 是指定 Dockerfile 的名字。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-29.png" alt="" loading="lazy"></p><p>然后 desktop 里看下构建出来的镜像：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-30.png" alt="" loading="lazy"></p><p>镜像体积比没有用多阶段构建的时候小了 250 M。</p><p>然后跑起来试试看：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-31.png" alt="" loading="lazy"></p><p>这次映射 2335 端口到容器内的 3000 端口。</p><p>依然能正常访问：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-32.png" alt="" loading="lazy"></p><p>这就是第二个技巧，多阶段构建。</p><h2 id="使用-arg-增加构建灵活性" tabindex="-1">使用 ARG 增加构建灵活性 <a class="header-anchor" href="#使用-arg-增加构建灵活性" aria-label="Permalink to &quot;使用 ARG 增加构建灵活性&quot;">​</a></h2><p>我们写一个 test.js</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(process.env.aaa);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(process.env.bbb);</span></span></code></pre></div><p>打印了环境变量 aaa、bbb</p><p>跑一下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>export aaa=1 bbb=2</span></span>
<span class="line"><span>node ./test.js</span></span></code></pre></div><p>可以看到打印了这俩环境变量：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-33.png" alt="" loading="lazy"></p><p>然后我们写个 dockerfile，文件名是 333.Dockerfile：</p><div class="language-docker vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">docker</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node:18-alpine3.14</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ARG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> aaa</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ARG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bbb</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WORKDIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /app</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ./test.js .</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ENV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> aaa=\${aaa} \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    bbb=\${bbb}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CMD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/app/test.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>使用 ARG 声明构建参数，使用 \${xxx} 来取</p><p>然后用 ENV 声明环境变量。</p><p>dockerfile 内换行使用 \\</p><p>之后构建的时候传入构建参数：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker build --build-arg aaa=3 --build-arg bbb=4 -t arg-test -f 333.Dockerfile .</span></span></code></pre></div><p>通过 --build-arg xxx=yyy 传入 ARG 参数的值。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-34.png" alt="" loading="lazy"></p><p>点击查看镜像详情，可以看到 ARG 已经被替换为具体的值了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-35.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-36.png" alt="" loading="lazy"></p><p>然后跑起来：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker run  --name fourth-container arg-test</span></span></code></pre></div><p>这次就不用 -d 后台运行了，直接看下日志：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-37.png" alt="" loading="lazy"></p><p>可以看到容器内拿到的环境变量就是 ENV 设置的。</p><p>也就是说 ARG 是构建时的参数，ENV 时运行时的变量。</p><p>灵活使用 ARG，可以增加 dockerfile 的灵活性。</p><p>这就是第三个技巧。</p><h2 id="cmd-结合-entrypoint" tabindex="-1">CMD 结合 ENTRYPOINT <a class="header-anchor" href="#cmd-结合-entrypoint" aria-label="Permalink to &quot;CMD 结合 ENTRYPOINT&quot;">​</a></h2><p>前面我们指定容器跑起来之后运行什么命令，用的是 CMD：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-38.png" alt="" loading="lazy"></p><p>其实还可以写成 ENTRYPOINT：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-39.png" alt="" loading="lazy"></p><p>这两种写法有什么区别么？</p><p>我们来试试：</p><p>写个 444.Dockerfile</p><div class="language-docker vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">docker</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node:18-alpine3.14</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CMD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;echo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;光光&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;到此一游&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>然后 build：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker build -t cmd-test -f 444.Dockerfile .</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-40.png" alt="" loading="lazy"></p><p>然后 run 一下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker run cmd-test</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-41.png" alt="" loading="lazy"></p><p>没有指定 --name 时，会生成一个随机容器名。</p><p>就是这种：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-42.png" alt="" loading="lazy"></p><p>这不是重点。</p><p>重点是用 CMD 的时候，启动命令是可以重写的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker run cmd-test echo &quot;东东&quot;</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-43.png" alt="" loading="lazy"></p><p>可以替换成任何命令。</p><p>而用 ENTRYPOINT 就不会：</p><div class="language-docker vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">docker</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node:18-alpine3.14</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ENTRYPOINT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;echo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;光光&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;到此一游&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>docker build:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker build -t cmd-test -f 444.Dockerfile .</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-44.png" alt="" loading="lazy"> docker run:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker run cmd-test echo &quot;东东&quot;</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-45.png" alt="" loading="lazy"></p><p>可以看到，现在 dockerfile 里 ENTRYPOINT 的命令依然执行了。</p><p>docker run 传入的参数作为了 echo 的额外参数。</p><p>这就是 ENTRYPOINT 和 CMD 的区别。</p><p>一般还是 CMD 用的多点，可以灵活修改启动命令。</p><p>其实 ENTRYPOINT 和 CMD 是可以结合使用的。</p><p>比如这样：</p><div class="language-docker vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">docker</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node:18-alpine3.14</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ENTRYPOINT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;echo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;光光&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CMD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;到此一游&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>docker build：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker build -t cmd-test -f 444.Dockerfile .</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-46.png" alt="" loading="lazy"></p><p>docker run:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker run cmd-test</span></span>
<span class="line"><span>docker run cmd-test 66666</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-47.png" alt="" loading="lazy"></p><p>当没传参数的时候，执行的是 ENTRYPOINT + CMD 组合的命令，而传入参数的时候，只有 CMD 部分会被覆盖。</p><p>这就起到了默认值的作用。</p><p>所以，用 ENTRYPOINT + CMD 的方式更加灵活。</p><p>这是第四个技巧。</p><h2 id="copy-vs-add" tabindex="-1">COPY vs ADD <a class="header-anchor" href="#copy-vs-add" aria-label="Permalink to &quot;COPY vs ADD&quot;">​</a></h2><p>其实不只是 ENTRYPOINT 和 CMD 相似，dockerfile 里还有一对指令也比较相似，就是 ADD 和 COPY。</p><p>这俩都可以把宿主机的文件复制到容器内。</p><p>但有一点区别，就是对于 tar.gz 这种压缩文件的处理上：</p><p>我们创建一个 aaa 目录，下面添加两个文件：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-48.png" alt="" loading="lazy"></p><p>使用 tar 命令打包：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>tar -zcvf aaa.tar.gz ./aaa</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-49.png" alt="" loading="lazy"></p><p>然后写个 555.Dockerfile</p><div class="language-docker vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">docker</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node:18-alpine3.14</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ./aaa.tar.gz /aaa</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ./aaa.tar.gz /bbb</span></span></code></pre></div><p>docker build 生成镜像：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker build -t add-test -f 555.Dockerfile .</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-50.png" alt="" loading="lazy"></p><p>docker run 跑起来：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker run -d --name sixth-container add-test</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-51.png" alt="" loading="lazy"></p><p>可以看到，ADD 把 tar.gz 给解压然后复制到容器内了。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-52.png" alt="" loading="lazy"></p><p>而 COPY 没有解压，它把文件整个复制过去了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-53.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-54.png" alt="" loading="lazy"></p><p>也就是说，ADD、COPY 都可以用于把目录下的文件复制到容器内的目录下。</p><p>但是 ADD 还可以解压 tar.gz 文件。</p><p>一般情况下，还是用 COPY 居多。</p><p>案例代码在<a href="https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/dockerfile-test" target="_blank" rel="noreferrer">小册仓库</a></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>Docker 是流行的容器技术，它可以在操作系统上创建多个隔离的容器，在容器内跑各种服务。</p><p>它的流程是 Dockerfile 经过 docker build 生成 docker 镜像，然后 docker run 来跑容器。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/42-55.png" alt="" loading="lazy"></p><p>docker run 的时候可以通过 -p 指定宿主机和容器的端口映射，通过 -v 挂载数据卷到容器内的某个目录。</p><p>CI/CD 基本也是这套流程，但是 Dockerfile 是要开发者自己维护的。</p><p>Dockerfile 有挺多技巧：</p><ul><li>使用 alpine 的镜像，而不是默认的 linux 镜像，可以极大减小镜像体积，比如 node:18-alpine3.14 这种</li><li>使用多阶段构建，比如一个阶段来执行 build，一个阶段把文件复制过去，跑起服务来，最后只保留最后一个阶段的镜像。这样使镜像内只保留运行需要的文件以及 dependencies。</li><li>使用 ARG 增加构建灵活性，ARG 可以在 docker build 时通过 --build-arg xxx=yyy 传入，在 dockerfile 中生效，可以使构建过程更灵活。如果是想定义运行时可以访问的变量，可以通过 ENV 定义环境变量，值使用 ARG 传入。</li><li>CMD 和 ENTRYPOINT 都可以指定容器跑起来之后运行的命令，CMD 可以被覆盖，而 ENTRYPOINT 不可以，两者结合使用可以实现参数默认值的功能。</li><li>ADD 和 COPY 都可以复制文件到容器内，但是 ADD 处理 tar.gz 的时候，还会做一下解压。</li></ul><p>灵活使用这些技巧，可以让你的 Dockerfile 更加灵活、性能更好。</p>`,255)]))}const r=a(l,[["render",e]]);export{k as __pageData,r as default};
