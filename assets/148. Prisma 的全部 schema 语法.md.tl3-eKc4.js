import{_ as a,c as n,o as p,ag as i}from"./chunks/framework.CCM1LoTM.js";const r=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"148. Prisma 的全部 schema 语法.md","filePath":"148. Prisma 的全部 schema 语法.md"}'),e={name:"148. Prisma 的全部 schema 语法.md"};function l(t,s,c,o,g,d){return p(),n("div",null,s[0]||(s[0]=[i(`<p>这节我们来学习下 Prisma 的 schema 文件的全部语法。</p><p>先创建个新项目：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mkdir prisma-schema</span></span>
<span class="line"><span>cd prisma-schema</span></span>
<span class="line"><span>npm init -y</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-1.png" alt="" loading="lazy"></p><p>全局安装 prisma：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm install -g prisma</span></span></code></pre></div><p>然后进入项目，执行 init 命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>prisma init</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-2.png" alt="" loading="lazy"></p><p>生成了 .env 和 schema 文件：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-3.png" alt="" loading="lazy"></p><p>然后改下 .env 文件的数据库连接信息：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-4.png" alt="" loading="lazy"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DATABASE_URL=&quot;mysql://root:guang@localhost:3306/prisma_test&quot;</span></span></code></pre></div><p>改一下 db 的 provider 为 mysql，并且添加一个 model</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-5.png" alt="" loading="lazy"></p><div class="language-prisma vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">prisma</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">generator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  provider </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;prisma-client-js&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">datasource</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> db</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  provider </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;mysql&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  url      </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> env</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;DATABASE_URL&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">model</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  id    </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     @id</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">autoincrement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  email </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  @unique</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name  </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然后执行 generate 命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>prisma generate</span></span></code></pre></div><p>会在 node_modules/@prisma/client 下生成客户端代码：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-6.png" alt="" loading="lazy"></p><p>这个生成位置是可以改的：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-7.png" alt="" loading="lazy"> 在 generator 指定 output 的位置即可：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>generator client {</span></span>
<span class="line"><span>  provider = &quot;prisma-client-js&quot;</span></span>
<span class="line"><span>  output   = &quot;../generated/client&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>然后再次 generate：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>prisma generate</span></span></code></pre></div><p>这时候就是在根目录生成的代码：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-8.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-9.png" alt="" loading="lazy"></p><p>此外，generator 除了可以生成 client 代码外，还可以生成别的东西。</p><p>在<a href="https://www.prisma.io/docs/concepts/components/prisma-schema/generators#community-generators" target="_blank" rel="noreferrer">文档</a>里可以看到有很多社区的 generator：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-10.png" alt="" loading="lazy"></p><p>我们试一下这个 json 和 docs 的 generator：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm install --save-dev prisma-docs-generator</span></span>
<span class="line"><span>npm install --save-dev prisma-json-schema-generator</span></span></code></pre></div><p>先安装相关的包。</p><p>然后在 schema 文件里配置 3 个 generator：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-11.png" alt="" loading="lazy"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>generator client {</span></span>
<span class="line"><span>  provider = &quot;prisma-client-js&quot;</span></span>
<span class="line"><span>  output   = &quot;../generated/client&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>generator docs {</span></span>
<span class="line"><span>  provider = &quot;node node_modules/prisma-docs-generator&quot;</span></span>
<span class="line"><span>  output   = &quot;../generated/docs&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>generator json {</span></span>
<span class="line"><span>  provider = &quot;prisma-json-schema-generator&quot;</span></span>
<span class="line"><span>  output   = &quot;../generated/json&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>把 generated 目录删掉，重新生成：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npx prisma generate</span></span></code></pre></div><p>注意，这里要用 npx 执行，因为如果是执行全局命令，会找不到项目目录下安装的 generator。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-12.png" alt="" loading="lazy"></p><p>提示三个 generator 的产物都输出到了对应目录。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-13.png" alt="" loading="lazy"></p><p>json schema 的 generator 会把 schema 文件转为 json 版：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-14.png" alt="" loading="lazy"></p><p>而 docs 则是会生成文档。</p><p>我们跑起来看看：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npx http-server ./generated/docs</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-15.png" alt="" loading="lazy"></p><p>文档里会列出 model 的所有字段：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-16.png" alt="" loading="lazy"></p><p>还有它的所有 CRUD 方法，每个方法的参数的类型等：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-17.png" alt="" loading="lazy"></p><p>当你想做 crud 的时候，查下这个生成的文档，特别方便。</p><p>datasource 部分是配置数据库连接信息的。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-18.png" alt="" loading="lazy"></p><p>provider 里指定连接的数据库的类型。</p><p>url 部分是连接的 url，也就是这个</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-19.png" alt="" loading="lazy"></p><p>在 schema 文件里可以用这种方式读取某个 env 的变量：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-20.png" alt="" loading="lazy"></p><p>接下来是 model 部分。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>model User {</span></span>
<span class="line"><span>  id    Int     @id @default(autoincrement())</span></span>
<span class="line"><span>  email String  @unique</span></span>
<span class="line"><span>  name  String?</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这部分很容易看懂，第一列是字段名，第二列是类型，第三列是一些其他信息。</p><p>首先重置一下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>prisma migrate reset</span></span></code></pre></div><p>我们用 migrate 命令生成 sql：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>prisma migrate dev --name aaa</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-21.png" alt="" loading="lazy"></p><p>然后创建一个 aaa 的迁移：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-22.png" alt="" loading="lazy"></p><p>它会创建对应的 sql 文件并执行：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-23.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-24.png" alt="" loading="lazy"></p><p>可以看到 model 的声明和生成的 sql 的对应关系：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>model User {</span></span>
<span class="line"><span>  id    Int     @id @default(autoincrement())</span></span>
<span class="line"><span>  email String  @unique</span></span>
<span class="line"><span>  name  String?</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-25.png" alt="" loading="lazy"></p><p>String 默认是 VARCHAR(191)</p><p>@id 会创建主键约束，@default 是默认值，而 autoincrement 是自增。</p><p>@unique 会创建唯一约束。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-26.png" alt="" loading="lazy"></p><p>我们再创建一个 model</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-27.png" alt="" loading="lazy"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>model Test {</span></span>
<span class="line"><span>  id Int @id @default(autoincrement())</span></span>
<span class="line"><span>  aaa String @db.Text</span></span>
<span class="line"><span>  bbb Int @db.TinyInt @map(&quot;bbb2&quot;)</span></span>
<span class="line"><span>  ccc String @db.VarChar(50) @unique</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  @@map(&quot;test_test&quot;)</span></span>
<span class="line"><span>  @@index([bbb, ccc])</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这是 @db.xxx 可以指定具体的 mysql 的数据类型，有括号的是可以填入参数的，比如 VARCHAR 可以指定长度：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-28.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-29.png" alt="" loading="lazy"></p><p>@map 是给字段指定另一个名字，@@map 是给表指定另一个名字。</p><p>而 @@index 则是创建一个索引，这里创建了 bbb、ccc 的联合索引。</p><p>索引就像书的目录一样，可以加快 sql 查询速度，sql 优化的时候我们经常会把高频查询的字段创建索引。</p><p>我们测试下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npx prisma migrate dev --name bbb</span></span></code></pre></div><p>创建 bbb 的数据库迁移。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-30.png" alt="" loading="lazy"> 生成的 sql 如下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-31.png" alt="" loading="lazy"></p><p>对比下 model 语法和生成的 sql：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>model Test {</span></span>
<span class="line"><span>  id Int @id @default(autoincrement())</span></span>
<span class="line"><span>  aaa String @db.Text</span></span>
<span class="line"><span>  bbb Int @db.TinyInt @map(&quot;bbb2&quot;)</span></span>
<span class="line"><span>  ccc String @db.VarChar(50) @unique</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  @@map(&quot;test_test&quot;)</span></span>
<span class="line"><span>  @@index([bbb, ccc])</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-32.png" alt="" loading="lazy"></p><p>可以看到 @db.xxx、@map、@@map、@@index 都生效了</p><p>在 mysql workbench 里也可以看到这个表：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-33.png" alt="" loading="lazy"></p><p>那表和表之间的一对多、多对多关系呢？</p><p>我们再添加几个 model：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-34.png" alt="" loading="lazy"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>model Department {</span></span>
<span class="line"><span>  id        Int    @id @default(autoincrement())</span></span>
<span class="line"><span>  name      String  @db.VarChar(20)</span></span>
<span class="line"><span>  createTime DateTime @default(now())</span></span>
<span class="line"><span>  updateTime DateTime @updatedAt</span></span>
<span class="line"><span>  employees     Employee[]</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>model Employee {</span></span>
<span class="line"><span>  id         Int       @id @default(autoincrement())</span></span>
<span class="line"><span>  name      String     @db.VarChar(20)</span></span>
<span class="line"><span>  phone     String     @db.VarChar(30)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  deaprtmentId Int</span></span>
<span class="line"><span>  department     Department      @relation(fields: [deaprtmentId], references: [id])</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这里用到了几个新语法：</p><p>创建时间我们使用 @default(now()) 的方式指定，这样插入数据的时候会自动填入当前时间。</p><p>更新时间使用 @updatedAt，会自动设置当前时间。</p><p>员工和部门是多对一关系，在员工那一侧添加一个 departmentId 的列，然后通过 @relation 声明 deaprtmentId 的列引用 department 的 id 列。</p><p>测试下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npx prisma migrate dev --name ccc</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-35.png" alt="" loading="lazy"></p><p>可以看到，生成的 sql 是符合预期的：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-36.png" alt="" loading="lazy"></p><p>并且在数据库里可以看到创建了对应的外键：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-37.png" alt="" loading="lazy"></p><p>然后是多对多：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-38.png" alt="" loading="lazy"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>model Post {</span></span>
<span class="line"><span>  id        Int          @id @default(autoincrement())</span></span>
<span class="line"><span>  title     String</span></span>
<span class="line"><span>  content   String?</span></span>
<span class="line"><span>  published Boolean      @default(false)</span></span>
<span class="line"><span>  tags      TagOnPosts[]</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>model Tag {</span></span>
<span class="line"><span>  id    Int          @id @default(autoincrement())</span></span>
<span class="line"><span>  name  String</span></span>
<span class="line"><span>  posts TagOnPosts[]</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>model TagOnPosts {</span></span>
<span class="line"><span>  post   Post @relation(fields: [postId], references: [id])</span></span>
<span class="line"><span>  postId Int</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  tag    Tag @relation(fields: [tagId], references: [id])</span></span>
<span class="line"><span>  tagId  Int</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  @@id([postId, tagId])</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>有 sql 的基础很容易看懂，多对多需要创建一个中间表，中间表里有两个外键分别关联这两个表。</p><p>然后用 @@id 创建一个联合主键。</p><p>测试下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npx prisma migrate dev --name ddd</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-39.png" alt="" loading="lazy"></p><p>生成的 sql 如下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-40.png" alt="" loading="lazy"></p><p>中间表创建了 postId 和 tagId 的联合主键，并且创建了两个外键。</p><p>在 mysql 里可以看到这两个外键：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-41.png" alt="" loading="lazy"></p><p>这就是一对多、多对多的映射方式。</p><p>至于一对一，那个就是在多的那一侧添加一个 unique 约束就好了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-42.png" alt="" loading="lazy"></p><p>这样就把一对多变成了一对一。</p><p>此外，还有一个 enum 的语法，就是可以指定某个字段只能取一些枚举值：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-43.png" alt="" loading="lazy"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>model Aaa {</span></span>
<span class="line"><span>  id      Int      @id @default(autoincrement())</span></span>
<span class="line"><span>  name    String?</span></span>
<span class="line"><span>  role    EEE     @default(CCC)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>enum EEE {</span></span>
<span class="line"><span>  BBB</span></span>
<span class="line"><span>  CCC</span></span>
<span class="line"><span>  DDD</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>创建迁移：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npx prisma migrate dev --name eee</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-44.png" alt="" loading="lazy"></p><p>生成的 sql 如下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-45.png" alt="" loading="lazy"></p><p>这个 enum 也是 sql 支持的语法（我们前面貌似没用过）。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-46.png" alt="" loading="lazy"></p><p>这就是 prisma schema 的常用语法了，有一些不常用的没有列出来，大家遇去查<a href="https://www.prisma.io/docs/concepts/components/prisma-schema" target="_blank" rel="noreferrer">schema 文档</a>就好了。</p><p>最后，再看下生成的文档：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npx http-server ./generated/docs</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-47.png" alt="" loading="lazy"></p><p>每一个表的字段还有可用的 CRUD 方法都列出来了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/148-48.png" alt="" loading="lazy"></p><p>确实很方便。</p><p>案例代码在<a href="https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/prisma-schema" target="_blank" rel="noreferrer">小册仓库</a></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>这节我们学习了 prisma schema 的常用语法。</p><p>generator 部分可以指定多种生成器，比如生成 json 生成 docs 等，可以指定生成代码的位置。</p><p>datasource 是配置数据库的类型和连接 url 的。</p><p>model 部分定义和数据库表的对应关系：</p><ul><li><strong>@id</strong> 定义主键</li><li><strong>@default</strong> 定义默认值</li><li><strong>@map</strong> 定义字段在数据库中的名字</li><li><strong>@db.xx</strong> 定义对应的具体类型</li><li><strong>@updatedAt</strong> 定义更新时间的列</li><li><strong>@unique</strong> 添加唯一约束</li><li><strong>@relation</strong> 定义外键引用</li><li><strong>@@map</strong> 定义表在数据库中的名字</li><li><strong>@@index</strong> 定义索引</li><li><strong>@@id</strong> 定义联合主键</li></ul><p>此外，还可以通过 enum 来创建枚举类型。</p><p>这些就是常用的 schema 语法了。</p>`,160)]))}const u=a(e,[["render",l]]);export{r as __pageData,u as default};
