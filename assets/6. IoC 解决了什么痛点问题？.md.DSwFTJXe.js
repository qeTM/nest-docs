import{_ as i,c as a,o as n,ag as p}from"./chunks/framework.BDwTZuFy.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"6. IoC 解决了什么痛点问题？.md","filePath":"6. IoC 解决了什么痛点问题？.md"}'),e={name:"6. IoC 解决了什么痛点问题？.md"};function l(t,s,h,o,r,c){return n(),a("div",null,s[0]||(s[0]=[p(`<p>后端系统中，会有很多对象：</p><ul><li>Controller 对象：接收 http 请求，调用 Service，返回响应</li><li>Service 对象：实现业务逻辑</li><li>Repository 对象：实现对数据库的增删改查</li></ul><p>此外，还有数据库链接对象 DataSource，配置对象 Config 等等。</p><p>这些对象有着错综复杂的关系：</p><p>Controller 依赖了 Service 实现业务逻辑，Service 依赖了 Repository 来做增删改查，Repository 依赖 DataSource 来建立连接，DataSource 又需要从 Config 对象拿到用户名密码等信息。</p><p>这就导致了创建这些对象是很复杂的，你要理清它们之间的依赖关系，哪个先创建哪个后创建。</p><p>比如这样：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ username: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;xxx&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, password: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;xxx&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dataSource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DataSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(config);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> repository</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Repository</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dataSource);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> service</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Service</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(repository);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> controller</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Controller</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(service);</span></span></code></pre></div><p>要经过一系列的初始化之后才可以使用 Controller 对象。</p><p>而且像 config、dataSource、repository、service、controller 等这些对象不需要每次都 new 一个新的，一直用一个就可以，也就是保持单例。</p><p>在应用初始化的时候，需要理清依赖的先后关系，创建一大堆对象组合起来，还要保证不要多次 new，是不是很麻烦？</p><p>没错，这是一个后端系统都有的痛点问题。</p><p>解决这个痛点的方式就是 IoC（Inverse of Control）。</p><p>java 的 Spring 就实现了 IoC，Nest 也同样实现了。</p><p>那什么是 IoC 呢？</p><p>之前我们手动创建和组装对象不是很麻烦么，我能不能在 class 上声明依赖了啥，然后让工具去分析我声明的依赖关系，根据先后顺序自动把对象创建好了并组装起来呢？</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-1.png" alt="" loading="lazy"></p><p>比如这样声明 AppController 依赖了这两个 Service，然后让工具分析依赖自动帮我创建好这三个对象并设置依赖关系。</p><p>这就是 IoC 的实现思路。</p><p>它有一个放对象的容器，程序初始化的时候会扫描 class 上声明的依赖关系，然后把这些 class 都给 new 一个实例放到容器里。</p><p>创建对象的时候，还会把它们依赖的对象注入进去。</p><p>这样不就完成了自动的对象创建和组装么？</p><p>这种依赖注入的方式叫做 Dependency Injection，简称 DI。</p><p>而这种方案为什么叫 IoC 也很容易理解了，本来是手动 new 依赖对象，然后组装起来，现在是声明依赖了啥，等待被注入。</p><p>从主动创建依赖到被动等待依赖注入，这就是 Inverse of Control，反转控制。</p><p>在 class 上声明依赖的方式，大家都选择了装饰器的方式（在 java 里这种语法叫做注解）。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-2.png" alt="" loading="lazy"></p><p>比如上面就是声明这个 class 要放到 IOC 容器里，然后它的依赖是啥。</p><p>这样 IOC 容器扫描到它就知道怎么创建它的对象了。</p><p>知道了 IOC 是啥，下面我们来看看真实的 Nest 项目里是怎么用 IoC 的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npx nest new nest-ioc</span></span></code></pre></div><p>执行上面的命令，它会创建一个 nest 项目：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-3.png" alt="" loading="lazy"></p><p>选择一个 npm 包管理工具，然后 nest cli 会自动创建项目结构并安装依赖：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-4.png" alt="" loading="lazy"></p><p>然后进入这个目录，执行 npm run start，把服务跑起来：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-5.png" alt="" loading="lazy"></p><p>浏览器访问 <a href="http://localhost:3000" target="_blank" rel="noreferrer">http://localhost:3000</a> 就可以看到 nest 服务返回的 hello world：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-6.png" alt="" loading="lazy"></p><p>我们看看代码里它是怎么创建对象的：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-7.png" alt="" loading="lazy"></p><p>它有一个 AppService 声明了 @Injectable，代表这个 class 可注入，那么 nest 就会把它的对象放到 IOC 容器里。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-8.png" alt="" loading="lazy"></p><p>AppController 声明了 @Controller，代表这个 class 可以被注入，nest 也会把它放到 IoC 容器里。</p><p>AppController 的构造器参数依赖了 AppService。</p><p>或者这样通过属性的方式声明依赖：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-9.png" alt="" loading="lazy"></p><p>前者是构造器注入，后者是属性注入，两种都可以。</p><p>为什么 Controller 是单独的装饰器呢？</p><p>因为 Service 是可以被注入也是可以注入到别的对象的，所以用 @Injectable 声明。</p><p>而 Controller 只需要被注入，所以 nest 单独给它加了 @Controller 的装饰器。</p><p>然后在 AppModule 里引入：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-10.png" alt="" loading="lazy"></p><p>通过 @Module 声明模块，其中 controllers 是控制器，只能被注入。</p><p>providers 里可以被注入，也可以注入别的对象，比如这里的 AppService。</p><p>然后在入口模块里跑起来：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-11.png" alt="" loading="lazy"></p><p>那么 nest 就会从 AppModule 开始解析 class 上通过装饰器声明的依赖信息，自动创建和组装对象。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-12.png" alt="" loading="lazy"></p><p>所以 AppController 只是声明了对 AppService 的依赖，就可以调用它的方法了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-13.png" alt="" loading="lazy"></p><p>nest 在背后自动做了对象创建和依赖注入的工作。</p><p>nest 还加了模块机制，可以把不同业务的 controller、service 等放到不同模块里。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nest g module other</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-14.png" alt="" loading="lazy"></p><p>会生成如下代码：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-15.png" alt="" loading="lazy"></p><p>用 nest cli 的 generate 命令生成一个模块。</p><p>会在 AppModule 里自动 imports 这个模块：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-16.png" alt="" loading="lazy"></p><p>当 import 别的模块后，那个模块 exports 的 provider 就可以在当前模块注入了。</p><p>比如我们再生成 OtherService：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nest g service other</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-17.png" alt="" loading="lazy"></p><p>会生成 Service 的代码：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-18.png" alt="" loading="lazy"></p><p>并自动添加到 OtherModule 的 providers 中：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-19.png" alt="" loading="lazy"></p><p>我们改下 OtherService，添加一个方法：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-20.png" alt="" loading="lazy"></p><p>然后在 OtherModule 里 exports：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-21.png" alt="" loading="lazy"></p><p>那当 AppModule 引用了 OtherModule 之后，就可以注入它 exports 的 OtherService 了。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-22.png" alt="" loading="lazy"></p><p>我们在 AppService 里注入下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { OtherService } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./other/other.service&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Inject, Injectable } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/common&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Injectable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AppService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(OtherService) </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  private</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> otherService</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OtherService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  getHello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Hello World!&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.otherService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">xxx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>把服务跑起来：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm run start:dev</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-23.png" alt="" loading="lazy"></p><p>浏览器访问下，可以看到 AppModule 的 AppService 调用 OtherModule 的 OtherService 成功了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/6-24.png" alt="" loading="lazy"></p><p>这就是 Nest 的 IoC 机制。</p><p>案例代码在<a href="https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-ioc" target="_blank" rel="noreferrer">小册仓库</a>。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>后端系统有很多的对象，这些对象之间的关系错综复杂，如果手动创建并组装对象比较麻烦，所以后端框架一般都提供了 IoC 机制。</p><p>IoC 机制是在 class 上标识哪些是可以被注入的，它的依赖是什么，然后从入口开始扫描这些对象和依赖，自动创建和组装对象。</p><p>Nest 里通过 @Controller 声明可以被注入的 controller，通过 @Injectable 声明可以被注入也可以注入别的对象的 provider，然后在 @Module 声明的模块里引入。</p><p>并且 Nest 还提供了 Module 和 Module 之间的 import，可以引入别的模块的 provider 来注入。</p><p>虽然 Nest 这套实现了 IoC 的模块机制看起来繁琐，但是却解决了后端系统的对象依赖关系错综复杂的痛点问题。</p>`,99)]))}const d=i(e,[["render",l]]);export{k as __pageData,d as default};
