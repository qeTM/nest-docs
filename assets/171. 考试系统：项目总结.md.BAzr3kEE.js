import{_ as a,c as i,o as n,ag as p}from"./chunks/framework.CCM1LoTM.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"171. 考试系统：项目总结.md","filePath":"171. 考试系统：项目总结.md"}'),l={name:"171. 考试系统：项目总结.md"};function g(t,s,e,c,o,h){return n(),i("div",null,s[0]||(s[0]=[p(`<p>学完了微服务和 monorepo 后，我们做了这个考试系统项目。</p><p>整体是模仿问卷星的流程，从创建考试、考试编辑器、答卷、自动判分、到排行榜等，流程比较完整。</p><p>我们通过 monorepo 的方式组织项目：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-1.png" alt="image.png" loading="lazy"></p><p>4 个微服务都是 apps 下的单独目录。</p><p>然后公共模块放在 libs 下，通过 @app/xxx 在项目里引入。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-2.png" alt="image.png" loading="lazy"></p><p>每个微服务都是独立跑的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm run start:dev user</span></span>
<span class="line"><span>npm run start:dev exam</span></span>
<span class="line"><span>npm run start:dev answer</span></span>
<span class="line"><span>npm run start:dev analyse</span></span></code></pre></div><p>之间通过 tcp 来实现通信：</p><p>比如 answer 微服务调用 exam 微服务：</p><p>在 exam 微服务暴露 tcp 端口：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-3.png" alt="image.png" loading="lazy"></p><p>answer 微服务连接上它：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-4.png" alt="image.png" loading="lazy"></p><p>在 exam 写一个消息处理函数：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-5.png" alt="image.png" loading="lazy"></p><p>在 answer 里调用它：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-6.png" alt="image.png" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-7.png" alt="" loading="lazy"></p><p>但这个项目的多个模块比较独立，最终也没用到 tcp 通信。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-8.png" alt="" loading="lazy"></p><p>同样，rabbitmq 的异步通信也没用到。</p><p>实际上大多数 node 项目我觉得都没必要用微服务架构，拆分会带来通信的复杂度，不如单体架构简单。</p><p>回顾下我们做这个项目的整个过程：</p><p>首先我们做了需求分析，分析了下有哪些功能：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-9.png" alt="image.png" loading="lazy"></p><p>直接用的问卷星的页面作为原型图：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-10.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-11.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-12.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-13.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-14.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-15.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-16.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-17.png" alt="" loading="lazy"></p><p>这一步主要是明确做什么。</p><p>然后我们设计了下技术方案，做了技术选型：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-18.png" alt="" loading="lazy"></p><p>当然，因为微服务之间比较独立，最终没用到微服务之间的同步（基于 tcp）和异步（基于消息队列）通信。</p><p>数据库设计：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-19.png" alt="image.png" loading="lazy"></p><p>分析了下接口：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-20.png" alt="image.png" loading="lazy"></p><p>接下来进入开发：</p><p>首先实现了 monorepo 架构：</p><p>创建了 user、exam、answer、analyse 这 4 个 app，还有 redis 这个公共 lib。</p><p>4 个微服务都单独暴露 http 接口在不同端口，之间还可以通过 TCP 来做通信。</p><p>libs 下的模块可以在每个 app 里引入，可以放一些公共代码。</p><p>然后实现了用户微服务的登录、注册、修改密码的功能。</p><p>过程中又创建了 prisma、email 的 lib。</p><p>通过 prisma 的 migrate 功能，生成迁移 sql 并同步到数据库。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-21.png" alt="image.png" loading="lazy"></p><p>之前用 TypeORM 也要做数据库迁移，不过需要自己准备这些 sql：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-22.png" alt="image.png" loading="lazy"></p><p>从数据库迁移方面来说，prisma 确实方便很多。</p><p>然后实现了考试微服务的接口，包括考试列表、考试创建、考试删除、发布考试、保存试卷内容的接口。</p><p>具体的试卷内容是用 JSON 存储的。</p><p>我们做了一个简单的低代码编辑器：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-23.png" alt="2024-08-27 20.33.03.gif" loading="lazy"></p><p>可以拖拽题型到画布区，然后在右侧编辑：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-24.png" alt="2024-08-26 23.08.21.gif" loading="lazy"></p><p>每个题目都设置分值、答案、答案解析</p><p>最终生成一个 json，把这个 json 保存到数据库。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-25.png" alt="image.png" loading="lazy"></p><p>其实一般的低代码编辑器都是编辑器拖拽，服务端存 JSON。</p><p>之后实现了这答卷微服务，包括创建答卷、答卷列表、答卷详情接口，导出答卷列表 excel 等接口。</p><p>然后实现了答题页面：</p><p>编辑完考试可以生成链接，打开链接答题后就会保存提交的答案。</p><p>渲染试卷 json 的逻辑和预览时一样。</p><p>表单 onChange 的时候修改 answers 状态，当点击提交的时候调用接口保存答卷。</p><p>这样从新建考试，编辑试卷，到答题提交答案的流程就完成了。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-26.png" alt="2024-08-27 20.37.29.gif" loading="lazy"></p><p>答题结果也是用 json 保存的。</p><p>格式是这样：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">        id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">        answer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">&#39;xxx&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">        id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">        answer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">&#39;yyy&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>我们通过和试卷 json 的答案对比，实现了分数的计算：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-27.png" alt="image.png" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-28.png" alt="image.png" loading="lazy"></p><p>之后又实现了排行榜。</p><p>排行榜的功能基于 redis 的 zset 实现，用 zadd 往其中添加元素，用 zrang 取排好序的前多少个元素，加上 REV 就是按照分数从大到小排序。</p><p>然后加了一个弹窗来展示排行榜。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/171-29.png" alt="2024-08-27 20.02.19.gif" loading="lazy"></p><p>这样，整个流程的功能就开发完了。</p><p>这个项目主要是熟悉了 monorepo 的架构，并且知道了低代码编辑器的存储方案。</p><p>如果你要开发微服务项目，也是基于这种 monorepo 的项目结构来开发。</p><p>整个项目流程都是对标问卷星来的，虽然有些简化，但功能是一样的。</p><p>不过这个项目比较简单，没用到微服务之间的通信。</p><p>实际上，单体架构的 node 项目占绝大多数，一般没必要用微服务的方式写，只会增加项目的复杂度。</p>`,89)]))}const d=a(l,[["render",g]]);export{y as __pageData,d as default};
