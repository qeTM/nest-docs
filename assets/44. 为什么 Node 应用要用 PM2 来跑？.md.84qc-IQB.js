import{_ as a,c as p,o as n,ag as i}from"./chunks/framework.CCM1LoTM.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"44. 为什么 Node 应用要用 PM2 来跑？.md","filePath":"44. 为什么 Node 应用要用 PM2 来跑？.md"}'),l={name:"44. 为什么 Node 应用要用 PM2 来跑？.md"};function e(c,s,o,t,g,h){return n(),p("div",null,s[0]||(s[0]=[i(`<p>前面我们都是 node 直接跑的 Nest 应用，但生产环境我们不会直接跑 node，而会用 pm2 来跑。</p><p>为什么要用 pm2 呢？它解决了啥问题？</p><p>想一下：</p><p>如果你的 node 应用跑的时候突然抛了个错，崩溃了，是不是需要重新跑起来？</p><p>这时候是不是就需要另一个进程来自动做重启这件事情？</p><p>node 应用的日志默认输出在控制台，如果想输出到不同的日志文件，是不是可以让另一个进程获取 node 应用的输出，然后写文件来实现？</p><p>node 是单线程的，而机器是多个 cpu 的，为了充分利用 cpu 的能力，我们会用多个进程来跑 node 应用，这种通用逻辑是不是也可以放到一个单独进程里来实现？</p><p>node 运行时的 cpu、内存等资源的占用，是不是需要监控？这时候是不是可以让另一个进程来做？</p><p>线上的 node 应用不只是跑起来就行了，还要做自动重启、日志、多进程、监控这些事情。</p><p>而这些事情，都可以用 pm2 来做。</p><p>pm2 是 process manager，进程管理，它是第二个大版本，和前一个版本差异很大，所以叫 pm2.</p><p>pm2 的主要功能就是<strong>进程管理、日志管理、负载均衡、性能监控</strong>这些。</p><p>我们分别来看一下：</p><p>首先安装 pm2:</p><pre><code>npm install -g pm2
</code></pre><p>然后跑一个 node 应用，我这里跑一个 Nest 的应用：</p><p>直接 node 跑是这样的，日志打印在控制台：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-1.png" alt="" loading="lazy"></p><p>而用 pm2 的话，就可以这样跑：</p><pre><code>pm2 start ./dist/main.js
</code></pre><p>它会把这个 node 进程跑起来，然后管理起来：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-2.png" alt="" loading="lazy"></p><p>管理起来之后，就有我们上面说的那些功能了，比如自动重启、日志管理、性能监控等。</p><p>首先看下日志，执行</p><pre><code>pm2 logs
</code></pre><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-3.png" alt="i" loading="lazy"></p><p>可以看到 pm2 会把所有进程的日志打印出来，通过前面的“进程id|进程名字”来区分，比如 0|main。</p><p>而且，它会把它写到日志文件里，在 ~/.pm2/logs 下，以“进程名-out.log”和“进程名-error.log”分别保存不同进程的日志：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-4.png" alt="" loading="lazy"></p><p>比如 main-out.log 里保存了 main 进程的正常日志，而 main-error.log 里保存了它的报错日志：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-5.png" alt="" loading="lazy"></p><p>我们再跑一个进程试试：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-6.png" alt="" loading="lazy"></p><p>现在有两个进程了，pm2 logs 可以看到这两个进程的日志：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-7.png" alt="" loading="lazy"></p><p>也可以</p><pre><code>pm2 logs 进程名
pm2 logs 进程id
</code></pre><p>这样查看单个进程的日志：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-8.png" alt="" loading="lazy"></p><p>这就是 pm2 的日志管理的功能。</p><p>进程管理的话就是可以手动启动、重启、停止某个进程，而且崩溃了会自动重启，也可以定时自动重启。</p><p>只需要 pm2 start 的时候带上几个选项就好了：</p><p>超过 200M 内存自动重启：</p><pre><code>pm2 start xxx --max-memory-restart 200M
</code></pre><p>从 2s 开始每 3s 重启一次：</p><pre><code>pm2 start xxx --cron-restart &quot;2/3 * * * * *&quot;
</code></pre><p>当文件内容改变自动重启：</p><pre><code>pm2 start xxx --watch
</code></pre><p>不自动重启：</p><pre><code>pm2 start xxx --no-autorestart
</code></pre><p>我们分别试一下：</p><p>把之前的进程删掉：</p><pre><code>pm2 delete 0
</code></pre><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-9.png" alt="" loading="lazy"></p><p>我们指定 1k 内存就重启：</p><pre><code>pm2 start xxx --max-memory-restart 1K
</code></pre><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-10.png" alt="" loading="lazy"></p><p>然后在 nest 代码里用超过 1k 的内存：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-11.png" alt="" loading="lazy"></p><p>先把之前的日志清空，使用 pm2 flush 或者 pm2 flush 进程名|id</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-12.png" alt="" loading="lazy"></p><p>确实清空了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-13.png" alt="" loading="lazy"></p><p>访问下这个 controller：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-14.png" alt="" loading="lazy"></p><p>查看 main 进程的前 100 行日志：</p><pre><code>pm2 logs main --lines 100 
</code></pre><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-15.png" alt="" loading="lazy"></p><p>明显看到重启了。</p><p>这是超过内存的自动重启。</p><p>崩溃的自动重启、定时自动重启、文件变动自动重启等也是类似 。</p><p>我们前面用到的 pm2 start、pm2 stop、pm2 restart、pm2 delete 等就是进程管理的功能。</p><p>再就是负载均衡，node 应用是单进程的，而为了充分利用多核 cpu，我们会使用多进程来提高性能。</p><p>node 提供的 cluster 模块就是做这个的，pm2 就是基于这个实现了负载均衡。</p><p>我们只要启动进程的时候加上 -i num 就是启动 num 个进程做负载均衡的意思。</p><pre><code>pm2 start app.js -i max 
pm2 start app.js -i 0
</code></pre><p>这俩是启动 cpu 数量的进程。</p><p>用多进程的方式跑 nest 应用：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-16.png" alt="" loading="lazy"></p><p>可以看到启动了 8 个进程，因为我是 8 核 cpu。</p><p>跑起来之后，还可以动态调整进程数，通过 pm2 scale：</p><pre><code>pm2 scale main 3
</code></pre><p>我把 main 的集群调整为 3 个进程：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-17.png" alt="" loading="lazy"></p><p>可以看到 pm2 删除了 5 个，留下了 3 个。</p><pre><code>pm2 scale main +3
</code></pre><p>我又加了 3 个，现在变成了 6 个：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-18.png" alt="" loading="lazy"></p><p>可以动态伸缩进程的数量，pm2 会把请求分配到不同进程上去。</p><p>这就是负载均衡功能。</p><p>此外，还有个性能监控功能，执行 pm2 monit:</p><pre><code>pm2 monit
</code></pre><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-19.png" alt="" loading="lazy"></p><p>可以看到不同进程的 cpu 和内存占用情况。</p><p>大概就是这些功能，但是当进程多了之后，难道都要手动通过命令行来启动么？</p><p>肯定不会每次都敲一遍。</p><p>pm2 支持配置文件的方式启动多个应用。</p><p>执行 pm2 ecosystem，会创建一个配置文件：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-20.png" alt="" loading="lazy"></p><p>apps 部分就是配置应用的，scripts 就是应用的启动路径：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-21.png" alt="" loading="lazy"></p><p>它可以指定的配置非常多，基本就是命令行有啥选项，这里就有啥属性：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-22.png" alt="" loading="lazy"></p><p>然后 pm2 start ecosystem.config.js 就可以批量跑一批应用。</p><p>就相当于 pm2 根据配置文件自动执行这些命令，不用我们手动敲了。</p><p>这样，我们就可以把启动的选项保存在配置文件里。</p><p>最后，还有个 pm2 plus，这个是收费功能，看看就行：</p><p>访问 pm2 的网站，登录，创建 bucket：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-23.png" alt="" loading="lazy"></p><p>然后在本地执行 pm2 link xxx xxx，把本地的 pm2 和那个网站关联起来：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-24.png" alt="" loading="lazy"></p><p>再执行 pm2 plus 就会打开 bucket 对应的网页：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-25.png" alt="" loading="lazy"></p><p>可以在线监控你的应用：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-26.png" alt="" loading="lazy"></p><p>下面这些 plus 的功能都是收费的：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-27.png" alt="" loading="lazy"></p><p>一般也不需要用，用免费的本地功能就好了。</p><p>有同学说，不都是 docker 部署了么？还需要 pm2 么？</p><p>当然需要了，万一 docker 容器内 node 服务崩溃了，是不是需要重启？</p><p>docker 容器内的进程同样有日志管理、进程管理和监控的需求。</p><p>一般都是 <a href="https://github.com/Unitech/pm2/blob/master/examples/docker-pm2/Dockerfile" target="_blank" rel="noreferrer">docker 镜像</a>内安装 pm2 来跑 node：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-28.png" alt="" loading="lazy"></p><p>之前我们写的 Nest 的 dockerfile 是这样的：</p><div class="language-docker vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">docker</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># build stage</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node:18 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> build-stage</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WORKDIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /app</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> package.json .</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> npm config set registry https://registry.npmmirror.com/</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> npm install</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> . .</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> npm run build</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># production stage</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node:18 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> production-stage</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> --from=build-stage /app/dist /app</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> --from=build-stage /app/package.json /app/package.json</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WORKDIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /app</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> npm install --production</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">EXPOSE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 3000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CMD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/app/main.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>现在要改成这样：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-29.png" alt="" loading="lazy"></p><p>就是多装一个 pm2，然后用 pm2 代替 node 来跑。</p><p>我们 docker build 一下：</p><pre><code>docker build -t nest:ccc .
</code></pre><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-30.png" alt="" loading="lazy"></p><p>把它跑起来：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-31.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-32.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-33.png" alt="" loading="lazy"></p><p>这个就是 pm2 打印的日志。</p><p>你可以在 terminal 使用 pm2 的命令：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/44-34.png" alt="" loading="lazy"></p><p>现在这个容器内的 node 进程在崩溃时就会自动重启。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>服务器上的 node 应用需要用 pm2 的日志管理、进程管理、负载均衡、性能监控等功能。</p><p>分别对应 pm2 logs、pm2 start/restart/stop/delete、pm2 start -i、pm2 monit 等命令。</p><p>多个应用或者想把启动选项保存下来的时候，可以通过 ecosystem 配置文件，批量启动一系列应用。</p><p>我们会把 docker 和 pm2 结合起来，在进程崩溃的时候让 pm2 来自动重启。</p><p>只要写 dockerfile 的时候多安装一个 pm2 的依赖，然后把 node 换成 pm2-runtime 就好了。</p><p>不管是出于稳定性、性能还是可观测性等目的，pm2 都是必不可少的。</p>`,146)]))}const r=a(l,[["render",e]]);export{d as __pageData,r as default};
