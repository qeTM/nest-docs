import{_ as a,c as i,o as n,ag as p}from"./chunks/framework.BDwTZuFy.js";const r=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"141. Nest 的 Monorepo 和 Library.md","filePath":"141. Nest 的 Monorepo 和 Library.md"}'),l={name:"141. Nest 的 Monorepo 和 Library.md"};function t(e,s,h,c,g,o){return n(),i("div",null,s[0]||(s[0]=[p(`<p>上节我们学习微服务时创建了 2 个 Nest 项目，如果微服务多了，可能会创建更多项目。</p><p>那问题来了，如果有 10 个微服务，我们就创建 10 个 Nest 项目的 git 仓库么？</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-1.png" alt="" loading="lazy"></p><p>那肯定不行，太难维护了。</p><p>这时候我们就需要 monorepo 了。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-2.png" alt="" loading="lazy"></p><p>这样，同一个 git 仓库中存放多个 Nest 项目，外层叫做 workspace。</p><p>这样就算是 10 个微服务项目，也能在一个 Git 仓库里管理起来。</p><p>Nest 是支持这种 monorepo 的方式的，我们来试试看：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nest new monorepo-test</span></span></code></pre></div><p>创建个 nest 项目</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-3.png" alt="" loading="lazy"></p><p>我们添加一个 aaa 的路由：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-4.png" alt="" loading="lazy"></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;aaa&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aaa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;aaa&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>改下端口：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-5.png" alt="" loading="lazy"></p><p>然后把它跑起来：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm run start:dev</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-6.png" alt="" loading="lazy"></p><p>浏览器访问下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-7.png" alt="" loading="lazy"></p><p>没啥问题。</p><p>然后我们再添加一个 nest 项目：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nest g app app2</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-8.png" alt="" loading="lazy"></p><p>它删除了 src 和 test，并创建了 apps 目录：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-9.png" alt="" loading="lazy"></p><p>这里的 apps/monorepo-test 就是之前的 src、test 代码：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-10.png" alt="" loading="lazy"></p><p>而 apps/app2 就是新创建的 nest 项目，或者叫 nest app。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-11.png" alt="" loading="lazy"></p><p>把之前的服务停掉，重新跑:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm run start:dev</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-12.png" alt="" loading="lazy"></p><p>可以看到，跑的还是之前的那个 nest 项目，只不过换成了 webpack 编译。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-13.png" alt="" loading="lazy"></p><p>为什么同样都是 nest run start:dev，换成 monorepo 的形式之后，还是跑之前项目呢？</p><p>答案在 nest-cli.json 里：</p><p>之前 nest-cli.json 是这样的：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-14.png" alt="" loading="lazy"></p><p>现在变成了这样：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-15.png" alt="" loading="lazy"></p><p>projects 下保存着多个 nest 项目的信息，比如根目录、入口文件、src 目录、编译配置文件。</p><p>然后 sourceRoot 和 root 分别指向了默认项目的 src 目录和根目录。</p><p>所以跑 nest start 的时候，才会依然跑的是之前的项目。</p><p>很明显，如果想跑另一个项目，就要这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm run start:dev app2</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-16.png" alt="" loading="lazy"></p><p>比如我在 app2 添加一个 bbb 的路由：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-17.png" alt="" loading="lazy"></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bbb&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bbb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;bbb&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>浏览器访问下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-18.png" alt="" loading="lazy"></p><p>这样，app2 的服务就跑起来了。</p><p>原理也很简单，就是 nest cli 会根据 app 名字去读取对应的 tscofnig 文件：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-19.png" alt="" loading="lazy"></p><p>这就是 nest 的 monorepo。</p><p>项目多了以后，难免有一些公共代码，这种公共代码怎么复用呢？</p><p>这就涉及到 nest 的另一个特性了：library。</p><p>创建一个 library：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nest g lib lib1</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-20.png" alt="" loading="lazy"></p><p>它会让你指定一个前缀，这里用默认的 @app。</p><p>然后会生成 libs/lib1 目录：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-21.png" alt="" loading="lazy"></p><p>在 src 下生成了 module、service 并把它们导出了。</p><p>还在 tsconfig.json 的 paths 下添加了对应的别名配置：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-22.png" alt="" loading="lazy"></p><p>在 nest-cli.json 里也多了这样一个 projects 配置：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-23.png" alt="" loading="lazy"></p><p>我们在 LibService 添加一个 xxx 方法：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-24.png" alt="" loading="lazy"></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">xxx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;xxx&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然后在 monorepo-test 的 app 里导入 Lib1Module：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-25.png" alt="" loading="lazy"></p><p>在 controller 里注入 Lib1Service 并调用它的方法：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-26.png" alt="" loading="lazy"></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Lib1Service)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">private </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : Lib1Service;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;aaa&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aaa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;aaa&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.lib.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">xxx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>同样的方式，在 app2 里也导入并使用它：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-27.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-28.png" alt="" loading="lazy"></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Lib1Service)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">private </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : Lib1Service;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bbb&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bbb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;bbb&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.lib.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">xxx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然后分别把两个服务跑起来：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm run start:dev</span></span>
<span class="line"><span></span></span>
<span class="line"><span>npm run start:dev app2</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-29.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-30.png" alt="" loading="lazy"></p><p>浏览器访问下 <a href="http://localhost:3001/aaa" target="_blank" rel="noreferrer">http://localhost:3001/aaa</a> 和 <a href="http://localhost:3000/bbb" target="_blank" rel="noreferrer">http://localhost:3000/bbb</a></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-31.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-32.png" alt="" loading="lazy"></p><p>可以看到，引入的 library 中的模块生效了。</p><p>如果你只是改 lib 下的代码，不想跑服务时，可以单独编译 lib 代码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm run start:dev lib1</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-33.png" alt="" loading="lazy"></p><p>nest 的 monorepo 和 libray 用起来都挺简单的。</p><p>还有个问题，现在 build 之后的代码是什么样的呢？</p><p>删掉 dist，然后执行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm run build</span></span></code></pre></div><p>产生了一个 apps/monorepo-test/main.js，因为现在换成 webpack 了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-34.png" alt="" loading="lazy"></p><p>然后执行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm run build app2</span></span></code></pre></div><p>现在就多了 apps/app2/main.js <img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-35.png" alt="" loading="lazy"></p><p>lib1 也是同理：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm run build lib1</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-36.png" alt="" loading="lazy"></p><p>之所以 application 或者 library 都能知道输出目录在哪，是因为在 tsconfig.json 里配了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-37.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-38.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/141-39.png" alt="" loading="lazy"></p><p>案例代码在<a href="https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/monorepo-test" target="_blank" rel="noreferrer">小册仓库</a></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>微服务项目可能会有很多个项目，为了方便管理，我们会使用 monorepo 的方式。</p><p>monorepo 就是在一个 git 仓库里管理多个项目。</p><p>nest cli 支持 monorepo，只要执行 nest g app xxx 就会把项目变为 monorepo 的，在 apps 下保存多个 nest 应用。</p><p>nest-cli.json 里配置了多个 projects 的信息，以及默认的 project。</p><p>npm run start:dev 或者 npm run build 可以加上应用名来编译对应的 app。</p><p>此外，多个项目可能有公共代码，这时候可以用 nest g lib xxx 创建 library。</p><p>library 保存在 libs 目录下，和 apps 一样可以有多个。</p><p>nest 会为 libs 创建别名，可以在其他 app 或者 lib 里用别名引入。</p><p>这就是 nest 里创建 monorepo 以及通过 library 复用代码的方式，用起来还是比较简单的。</p>`,121)]))}const k=a(l,[["render",t]]);export{r as __pageData,k as default};
