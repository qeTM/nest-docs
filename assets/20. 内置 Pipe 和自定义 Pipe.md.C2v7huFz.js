import{_ as s,c as i,o as n,ag as p}from"./chunks/framework.BDwTZuFy.js";const r=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"20. 内置 Pipe 和自定义 Pipe.md","filePath":"20. 内置 Pipe 和自定义 Pipe.md"}'),l={name:"20. 内置 Pipe 和自定义 Pipe.md"};function e(g,a,c,o,t,u){return n(),i("div",null,a[0]||(a[0]=[p(`<p>Pipe 是在参数传给 handler 之前对参数做一些验证和转换的 class，</p><p>对应的源码如下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-1.png" alt="" loading="lazy"></p><p>对每个参数都会应用 pipe：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-2.png" alt="" loading="lazy"></p><p>内置的 Pipe 有这些：</p><ul><li>ValidationPipe</li><li>ParseIntPipe</li><li>ParseBoolPipe</li><li>ParseArrayPipe</li><li>ParseUUIDPipe</li><li>DefaultValuePipe</li><li>ParseEnumPipe</li><li>ParseFloatPipe</li><li>ParseFilePipe</li></ul><p>它们都实现了 PipeTransform 接口：</p><p>比如 ParseIntPipe 的源码是这样的：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-3.png" alt="" loading="lazy"></p><p>我们分别来试下内置的 Pipe 的功能吧。</p><p>创建个项目：</p><pre><code>nest new pipe-test -p npm
</code></pre><p>参数默认是 string 类型：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-4.png" alt="" loading="lazy"></p><p>我们可以通过 Pipe 把它转为整数：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-5.png" alt="" loading="lazy"></p><p>效果如下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-6.png" alt="" loading="lazy"></p><p>当你传入的参数不能 parse 为 int 时，会返回这样的响应：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-7.png" alt="" loading="lazy"></p><p>这个也是可以修改的，但要使用 new XxxPipe 的方式：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-8.png" alt="" loading="lazy"></p><p>比如我指定错误时的状态码为 404。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-9.png" alt="" loading="lazy"></p><p>就会返回这样的响应。</p><p>此外，你还可以自己抛一个异常出来，然后让 exception filter 处理：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-10.png" alt="" loading="lazy"></p><p>可以看到，状态码和 message 都改了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-11.png" alt="" loading="lazy"></p><p>你也可以加个 @UseFilters 来使用自己的 exception filter 处理。</p><p>ParseFloatPipe 是把参数转换为 float 类型的。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-12.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-13.png" alt="" loading="lazy"></p><p>它也同样可以 new ParseFloatPipe 的形式，传入 errorHttpStatusCode 和 exceptionFactory。</p><p>剩下这些与 parse 有关的 pipe 我们都试一下：</p><p>ParseBoolPipe：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-14.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-15.png" alt="" loading="lazy"></p><p>ParseArrayPipe：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-16.png" alt="" loading="lazy"></p><p>这时会提示需要 class-validator 这个包：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-17.png" alt="" loading="lazy"></p><p>这是可以用装饰器和非装饰器两种方式对 class 属性做验证的库</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-18.png" alt="" loading="lazy"></p><p>还会提示需要 class-transformer 这个包：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-19.png" alt="" loading="lazy"></p><p>它是把普通对象转换为对应的 class 实例的包：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-20.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-21.png" alt="" loading="lazy"></p><p>后面我们也会用到这俩包。</p><p>安装这俩包：</p><pre><code>npm install -D class-validator class-transformer
</code></pre><p>然后访问下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-22.png" alt="" loading="lazy"></p><p>你会发现它确实把每一项都提取出来了，但是没有转为 number。</p><p>这时候就需要用 new XxxPipe 的方式传入参数了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-23.png" alt="" loading="lazy"></p><p>指定 item 的类型。</p><p>这样就把数组每一项处理为 number 了。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-24.png" alt="" loading="lazy"></p><p>此外，你还可以指定分隔符：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-25.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-26.png" alt="" loading="lazy"></p><p>当没有传参数的时候会报错：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-27.png" alt="" loading="lazy"></p><p>可以把它设置为 optional：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-28.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-29.png" alt="" loading="lazy"></p><p>然后是 ParseEnumPipe：</p><p>假设我们有这样一个枚举：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-30.png" alt="" loading="lazy"></p><p>就可以用 ParseEnumPipe 来取：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-31.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-32.png" alt="" loading="lazy"></p><p>有同学说，这不是多此一举么，本来 @Param 也能把它取出来呀。</p><p>ParseEnumPipe 还是有用的：</p><p>第一个是可以限制参数的取值范围：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-33.png" alt="" loading="lazy"></p><p>如果参数值不是枚举里的，就会报错。</p><p>这个错误自然也可以通过 errorHttpStatusCode 和 exceptionFactory 来定制。</p><p>第二个是帮你转换类型：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-34.png" alt="" loading="lazy"></p><p>这里拿到的就直接是枚举类型了，如果有个方法的参数是这样的枚举类型，就可以直接传入。</p><p>接下来是 ParseUUIDPipe：</p><p>UUID 是一种随机生成的几乎不可能重复的字符串，可以用来做 id。</p><p>它有 v3、v4、v5 3 个版本，我们用 uuid 包可以生成这种 id：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-35.png" alt="" loading="lazy"></p><p>在参数里，可以用 ParseUUIDPipe 来校验是否是 UUID：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-36.png" alt="" loading="lazy"></p><p>如果不是 uuid 会抛异常：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-37.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-38.png" alt="" loading="lazy"></p><p>接下来是 DefaultValuePipe：</p><p>这个是设置参数默认值的：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-39.png" alt="" loading="lazy"></p><p>当你没传参数的时候，会使用默认值：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-40.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-41.png" alt="" loading="lazy"></p><p>它的源码也很简单：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-42.png" alt="" loading="lazy"></p><p>还剩下 ValidationPipe 和 ParseFilePipe，这个我们之后再讲。</p><p>接下来我们自己实现个 Pipe 试一下：</p><pre><code>nest g pipe aaa --flat --no-spec
</code></pre><p>生成一个 pipe，打印下参数值，返回 aaa：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-43.png" alt="" loading="lazy"></p><p>在 handler 里用下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-44.png" alt="" loading="lazy"></p><p>浏览器访问这个接口：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-45.png" alt="" loading="lazy"></p><p>返回的值是 aaaaaa，也就是说 pipe 的返回值就是传给 handler 的参数值。</p><p>打印的 value 就是 query、param 的值，而 metadata 里包含 type、metatype、data：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-46.png" alt="" loading="lazy"></p><p>type 就是 @Query、@Param、@Body 装饰器，或者自定义装饰器：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-47.png" alt="" loading="lazy"></p><p>而 metatype 是参数的 ts 类型：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/20-48.png" alt="" loading="lazy"></p><p>data 是传给 @Query、@Param、@Body 等装饰器的参数。</p><p>有了这些东西，做一下验证，抛出异常给 exception filter 处理，或者对 value 做些转换再传给 handler 就都是很简单的事情了。</p><p>案例代码在<a href="https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/pipe-test" target="_blank" rel="noreferrer">小册仓库</a>。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>Pipe 是在参数传给 handler 之前做一些验证和转换的，有 9 个内置的 Pipe 可以直接用。</p><p>我们过了一遍内置的 ParseIntPipe、ParseBoolPipe、ParseArrayPipe、ParseUUIDPipe、ParseEnumPipe、ParseFloatPipe 还有 DefaultValuePipe。</p><p>剩下的 ValidationPipe 和 ParseFilePipe 之后的章节讲。</p><p>自己写一个 pipe 也很简单，就是实现 PipeTransform 接口的 transform 方法，它的返回值就是传给 handler 的值。</p><p>在 pipe 里可以拿到装饰器和 handler 参数的各种信息，基于这些来实现校验和转换就是很简单的事情了。</p>`,126)]))}const h=s(l,[["render",e]]);export{r as __pageData,h as default};
