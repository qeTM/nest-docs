import{_ as d,c as r,o as e,ag as a}from"./chunks/framework.BDwTZuFy.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"110. 会议室预订系统：技术方案和数据库设计.md","filePath":"110. 会议室预订系统：技术方案和数据库设计.md"}'),i={name:"110. 会议室预订系统：技术方案和数据库设计.md"};function o(s,t,n,h,p,l){return e(),r("div",null,t[0]||(t[0]=[a('<p>上节我们梳理了有哪些需求，并且画了原型图，明确了要做什么。</p><p>这节我们来过一下技术方案，设计下数据库，也就是怎么做。</p><h2 id="技术栈" tabindex="-1">技术栈 <a class="header-anchor" href="#技术栈" aria-label="Permalink to &quot;技术栈&quot;">​</a></h2><p>我们要做的是一个全栈项目，前端用 React + AntD （或者可以换成其他前端框架），后端用 Nest。</p><p>技术栈如下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/110-1.png" alt="" loading="lazy"></p><p>前端使用 create-react-app 脚手架创建项目，使用 react + antd 开发页面。</p><p>使用 nginx 来网关层，实现静态资源的托管，并且对于动态资源请求做负载均衡。</p><p>使用 Nest 开发后端业务逻辑，使用 TypeORM + mysql 来做 CRUD。</p><p>使用 Redis 来做缓存，减轻数据库的压力，提高响应性能。</p><p>api 文档使用 Swagger 来生成。</p><p>部署使用 Docker Compose 的方式。</p><p>PM2 可用可不用，不用 PM2 就要启动容器的时候指定重启策略了，这里为了简单我们还是用 PM2。</p><p>都是前面讲过的技术，这里只是综合运用。</p><p>然后来设计下数据库：</p><h2 id="数据库设计" tabindex="-1">数据库设计 <a class="header-anchor" href="#数据库设计" aria-label="Permalink to &quot;数据库设计&quot;">​</a></h2><p>首先是用户表 users：</p><table tabindex="0"><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>用户ID</td></tr><tr><td>username</td><td>VARCHAR(50)</td><td>用户名</td></tr><tr><td>password</td><td>VARCHAR(50)</td><td>密码</td></tr><tr><td>nick_name</td><td>VARCHAR(50)</td><td>昵称</td></tr><tr><td>email</td><td>VARCHAR(50)</td><td>邮箱</td></tr><tr><td>head_pic</td><td>VARCHAR(100)</td><td>头像</td></tr><tr><td>phone_number</td><td>VARCHAR(20)</td><td>手机号</td></tr><tr><td>is_frozen</td><td>BOOLEAN</td><td>是否被冻结</td></tr><tr><td>is_admin</td><td>BOOLEAN</td><td>是否是管理员</td></tr><tr><td>create_time</td><td>DATETIME</td><td>创建时间</td></tr><tr><td>update_time</td><td>DATETIME</td><td>更新时间</td></tr></tbody></table><p>用户需要区分普通用户和管理员，所以加了个 is_admin 字段。</p><p>然后是会议室表 meeting_rooms：</p><table tabindex="0"><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>会议室ID</td></tr><tr><td>name</td><td>VARCHAR(50)</td><td>会议室名字</td></tr><tr><td>capacity</td><td>INT</td><td>会议室容量</td></tr><tr><td>location</td><td>VARCHAR(50)</td><td>会议室位置</td></tr><tr><td>equipment</td><td>VARCHAR(50)</td><td>设备</td></tr><tr><td>description</td><td>VARCHAR(100)</td><td>描述</td></tr><tr><td>is_booked</td><td>BOOLEAN</td><td>是否被预订</td></tr><tr><td>create_time</td><td>DATETIME</td><td>创建时间</td></tr><tr><td>update_time</td><td>DATETIME</td><td>更新时间</td></tr></tbody></table><p>接下来是预订表 bookings：</p><table tabindex="0"><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>预订ID</td></tr><tr><td>user_id</td><td>INT</td><td>预订用户ID</td></tr><tr><td>room_id</td><td>INT</td><td>会议室ID</td></tr><tr><td>start_time</td><td>DATETIME</td><td>会议开始时间</td></tr><tr><td>end_time</td><td>DATETIME</td><td>会议结束时间</td></tr><tr><td>status</td><td>VARCHAR(20)</td><td>状态（申请中、审批通过、审批驳回、已解除）</td></tr><tr><td>note</td><td>VARCHAR(100)</td><td>备注</td></tr><tr><td>create_time</td><td>DATETIME</td><td>创建时间</td></tr><tr><td>update_time</td><td>DATETIME</td><td>更新时间</td></tr></tbody></table><p>然后是预订-参会人表 booking_attendees：</p><table tabindex="0"><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>ID</td></tr><tr><td>user_id</td><td>INT</td><td>参会用户ID</td></tr><tr><td>booking_id</td><td>INT</td><td>预订ID</td></tr></tbody></table><p>这几个表的关系如下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/110-2.png" alt="" loading="lazy"></p><p>再加上角色表、权限表，还有 2 个中间表：</p><p>角色表 roles</p><table tabindex="0"><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>ID</td></tr><tr><td>name</td><td>VARCHAR(20)</td><td>角色名</td></tr></tbody></table><p>权限表 permissions</p><table tabindex="0"><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>ID</td></tr><tr><td>code</td><td>VARCHAR(20)</td><td>权限代码</td></tr><tr><td>description</td><td>VARCHAR(100)</td><td>权限描述</td></tr></tbody></table><p>用户-角色中间表 user_roles</p><table tabindex="0"><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>ID</td></tr><tr><td>user_id</td><td>INT</td><td>用户 ID</td></tr><tr><td>role_id</td><td>INT</td><td>角色 ID</td></tr></tbody></table><p>角色-权限中间表 role_permissions</p><table tabindex="0"><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>ID</td></tr><tr><td>role_id</td><td>INT</td><td>角色 ID</td></tr><tr><td>permission_id</td><td>INT</td><td>权限 ID</td></tr></tbody></table><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/110-3.png" alt="" loading="lazy"></p><p>设计完数据库，我们再来划分下模块：</p><h2 id="模块划分" tabindex="-1">模块划分 <a class="header-anchor" href="#模块划分" aria-label="Permalink to &quot;模块划分&quot;">​</a></h2><p>首先是用户模块，实现普通用户和管理员的登录、注册、信息修改的功能：</p><p>大概有这些接口：</p><table tabindex="0"><thead><tr><th>接口路径</th><th>请求方式</th><th>描述</th></tr></thead><tbody><tr><td>/user/login</td><td>POST</td><td>普通用户登录</td></tr><tr><td>/user/register</td><td>POST</td><td>普通用户注册</td></tr><tr><td>/user/update</td><td>POST</td><td>普通用户个人信息修改</td></tr><tr><td>/user/update_password</td><td>POST</td><td>普通用户修改密码</td></tr><tr><td>/user/admin/login</td><td>POST</td><td>管理员登录</td></tr><tr><td>/user/admin/update_password</td><td>POST</td><td>管理员修改密码</td></tr><tr><td>/user/admin/update</td><td>POST</td><td>管理员个人信息修改</td></tr><tr><td>/user/list</td><td>GET</td><td>用户列表</td></tr><tr><td>/user/freeze</td><td>GET</td><td>冻结用户</td></tr></tbody></table><p>然后是会议室管理模块：</p><table tabindex="0"><thead><tr><th>接口路径</th><th>请求方式</th><th>描述</th></tr></thead><tbody><tr><td>/meeting_room/list</td><td>GET</td><td>会议室列表</td></tr><tr><td>/meeting_room/delete/:id</td><td>DELETE</td><td>会议室删除</td></tr><tr><td>/meeting_room/update/:id</td><td>PUT</td><td>会议室更新</td></tr><tr><td>/meeting_room/create</td><td>POST</td><td>会议室新增</td></tr><tr><td>/meeting_room/search</td><td>GET</td><td>会议室搜索</td></tr></tbody></table><p>然后是预订管理模块：</p><table tabindex="0"><thead><tr><th>接口路径</th><th>请求方式</th><th>描述</th></tr></thead><tbody><tr><td>/booking/list</td><td>GET</td><td>预订列表</td></tr><tr><td>/booking/approve</td><td>POST</td><td>审批预订申请</td></tr><tr><td>/booking/add</td><td>POST</td><td>申请预订</td></tr><tr><td>/booking/apply/:id</td><td>GET</td><td>通过预订</td></tr><tr><td>/booking/reject/:id</td><td>GET</td><td>取消预订</td></tr><tr><td>/booking/unbind/:id</td><td>GET</td><td>解除预订</td></tr><tr><td>/booking/history</td><td>GET</td><td>预订历史</td></tr><tr><td>/booking/urge</td><td>GET</td><td>催办</td></tr></tbody></table><p>然后是统计模块：</p><table tabindex="0"><thead><tr><th>接口路径</th><th>请求方式</th><th>描述</th></tr></thead><tbody><tr><td>/statistics/meeting_room_usage_frequency</td><td>GET</td><td>会议室使用频率统计</td></tr><tr><td>/statistics/user_booking_frequency</td><td>GET</td><td>用户预订频率统计</td></tr></tbody></table><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/110-4.png" alt="" loading="lazy"></p><h2 id="角色划分" tabindex="-1">角色划分 <a class="header-anchor" href="#角色划分" aria-label="Permalink to &quot;角色划分&quot;">​</a></h2><p>权限控制使用 RBAC 的方式，有普通用户和管理员两个角色，</p><p>两个角色各自可以操作的接口就是上节用例图画的那些：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/110-5.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/110-6.png" alt="" loading="lazy"></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/110-7.png" alt="" loading="lazy"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>这节我们设计了下技术方案。</p><p>技术栈：前端是 antd + react + cra，后端是 nest + typeorm，数据库是 mysql + redis，API 文档用 swagger 生成，部署用 docker compose + pm2，网关使用 nginx。</p><p>数据库表有 8 个：用户表 users、会议室表 meeting_rooms、预订表 bookings、预订-参会者表 booking_attendees、角色表 roles、权限表 permissions、用户-角色表 user_roles、角色-权限表 role_permissions。</p><p>模块有 4 个：用户管理模块、会议室管理模块、预订管理模块、统计管理模块。</p><p>角色有两个：普通用户、管理员，各自拥有的权限按照用例图来。使用 RBAC 来控制接口访问权限。</p><p>技术方案确定之后，下节开始我们就正式进入开发了。</p>',62)]))}const _=d(i,[["render",o]]);export{c as __pageData,_ as default};
